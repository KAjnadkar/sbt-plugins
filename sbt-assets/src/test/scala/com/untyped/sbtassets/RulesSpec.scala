package com.untyped.sbtassets

import sbt._

class RulesSpec extends BaseSpec {
  describe("Cat") {
    val inDir =
      createTemporaryFiles(
        "a.txt" -> "a",
        "b.txt" -> "b",
        "c.txt" -> "c"
      )

    val outDir =
      IO.createTemporaryDirectory

    val sources =
      Selectors.Const(List(
        Source(Path("/a"), inDir / "a.txt", Nil),
        Source(Path("/b"), inDir / "b.txt", Nil),
        Source(Path("/c"), inDir / "c.txt", Nil)
      ))

    val cat =
      Rules.Cat(outDir / "out.txt", sources)

    it("should return sources") {
      cat.sources must equal (List(Source(Path.Root, outDir / "out.txt", Nil)))
      (outDir / "out.txt").exists must equal (false)
    }

    it("should compile sources") {
      (outDir / "out.txt").delete
      (outDir / "out.txt").exists must equal (false)

      cat.compile must equal (List(Source(Path.Root, outDir / "out.txt", Nil)))
      (outDir / "out.txt").exists must equal (true)
      IO.read(outDir / "out.txt") must equal ("abc")

      cat.compile must equal (Nil)
    }
  }

  describe("Coffee") {
    val inDir =
      createTemporaryFiles(
        "a.coffee" -> "alert 'a'",
        "b.coffee" -> "alert 'b'",
        "c.coffee" -> "alert 'c'"
      )

    val inSources =
      Selectors.Const(List(
        Source(Path("/a"), inDir / "a.coffee", Nil),
        Source(Path("/b"), inDir / "b.coffee", Nil),
        Source(Path("/c"), inDir / "c.coffee", Nil)
      ))

    val outDir =
      IO.createTemporaryDirectory

    val outSources =
      Selectors.Const(List(
        Source(Path("/a"), outDir / "a.js", Nil),
        Source(Path("/b"), outDir / "b.js", Nil),
        Source(Path("/c"), outDir / "c.js", Nil)
      ))

    val rule =
      Rules.Coffee(outDir, inSources)

    it("should return sources") {
      rule.sources must equal (outSources.sources)
      outSources.sources.map(_.file.exists).foldLeft(false)(_ || _) must equal (false)
    }

    it("should compile sources") {
      outSources.sources.foreach(_.file.delete)
      outSources.sources.map(_.file.exists).foldLeft(false)(_ || _) must equal (false)

      rule.compile must equal (outSources.sources)
      outSources.sources.map(_.file.exists).foldLeft(true)(_ && _) must equal (true)
      IO.read(outDir / "a.js") must equal {
        """
        |// Generated by CoffeeScript 1.6.2
        |alert('a');
        |
        """.trim.stripMargin
      }

      rule.compile must equal (Nil)
    }
  }

  describe("Rewrite") {
    val inDir =
      createTemporaryFiles(
        "a.txt" -> "a",
        "b.txt" -> "b",
        "c.txt" -> "c"
      )

    val inSources =
      Selectors.Const(List(
        Source(Path("/a"), inDir / "a.txt", Nil),
        Source(Path("/b"), inDir / "b.txt", Nil),
        Source(Path("/c"), inDir / "c.txt", Nil)
      ))

    val outDir =
      IO.createTemporaryDirectory

    val outSources =
      Selectors.Const(List(
        Source(Path("/a"), outDir / "a.txt", Nil),
        Source(Path("/b"), outDir / "b.txt", Nil),
        Source(Path("/c"), outDir / "c.txt", Nil)
      ))

    val rule =
      Rules.Rewrite(
        outDir,
        (in: Source, contents: String) =>
          "[header " + in.path + "]" + contents + "[footer " + in.path + "]",
        inSources
      )

    it("should return sources") {
      rule.sources must equal (outSources.sources)
      (outDir / "out.txt").exists must equal (false)
    }

    it("should compile sources") {
      rule.compile must equal (outSources.sources)
      outSources.sources.map(_.file.exists).foldLeft(true)(_ && _) must equal (true)
      IO.read(outDir / "a.txt") must equal ("[header /a]a[footer /a]")

      rule.compile must equal (Nil)
    }
  }

  describe("UglifyJs") {
    val inDir =
      createTemporaryFiles(
        "a.txt" -> "a",
        "b.txt" -> "b",
        "c.txt" -> "c"
      )

    val outDir =
      IO.createTemporaryDirectory

    val sources =
      Selectors.Const(List(
        Source(Path("/a"), inDir / "a.txt", Nil),
        Source(Path("/b"), inDir / "b.txt", Nil),
        Source(Path("/c"), inDir / "c.txt", Nil)
      ))

    val rule =
      Rules.UglifyJs(outDir / "out.txt", sources)

    it("should return sources") {
      rule.sources must equal (List(Source(Path.Root, outDir / "out.txt", Nil)))
      (outDir / "out.txt").exists must equal (false)
    }

    it("should compile sources") {
      (outDir / "out.txt").delete
      (outDir / "out.txt").exists must equal (false)

      rule.compile must equal (List(Source(Path.Root, outDir / "out.txt", Nil)))
      (outDir / "out.txt").exists must equal (true)
      IO.read(outDir / "out.txt") must equal ("a;b;c;")

      rule.compile must equal (Nil)
    }
  }
}