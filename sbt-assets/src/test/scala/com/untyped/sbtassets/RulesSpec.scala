package com.untyped.sbtassets

import sbt._

class RulesSpec extends BaseSpec {

  describe("Cat") {
    val inDir      = createTemporaryFiles(
                       "a.txt" -> "a",
                       "b.txt" -> "b",
                       "c.txt" -> "c"
                     )
    val inAssets  = Selectors.Const(List(
                       Asset(Path("/a"), inDir / "a.txt", Nil),
                       Asset(Path("/b"), inDir / "b.txt", Nil),
                       Asset(Path("/c"), inDir / "c.txt", Nil)
                     ))
    val outDir     = IO.createTemporaryDirectory
    val outAssets = Selectors.Const(List(
                       Asset(Path.Root, outDir / "out.txt", Nil)
                     ))
    val rule       = Rules.Cat(outDir / "out.txt", inAssets)

    it("should return assets") {
      rule.assets must equal (outAssets.assets)
      (outDir / "out.txt") must not (exist)
    }

    it("should compile assets") {
      (outDir / "out.txt") must not (exist)
      (outDir / "out.txt") must (changeDuring {
        rule.compile(log)
      })
      IO.read(outDir / "out.txt") must equal ("abc")
      (outDir / "out.txt") must not (changeDuring {
        rule.compile(log)
      })
    }

    it("should clean the correct assets") {
      (outDir / "out.txt") must exist
      rule.clean(log)

      (inDir / "a.txt") must exist
      (outDir / "out.txt")  must not (exist)
    }
  }

  describe("Coffee") {
    val inDir      = createTemporaryFiles(
                       "a.coffee" -> "alert 'a'",
                       "b.coffee" -> "alert 'b'",
                       "c.coffee" -> "alert 'c'"
                     )
    val inAssets  = Selectors.Const(List(
                       Asset(Path("/a"), inDir / "a.coffee", Nil),
                       Asset(Path("/b"), inDir / "b.coffee", Nil),
                       Asset(Path("/c"), inDir / "c.coffee", Nil)
                     ))
    val outDir     = IO.createTemporaryDirectory
    val outAssets = Selectors.Const(List(
                       Asset(Path("/a"), outDir / "a.js", Nil),
                       Asset(Path("/b"), outDir / "b.js", Nil),
                       Asset(Path("/c"), outDir / "c.js", Nil)
                     ))
    val rule       = Rules.Coffee(outDir, inAssets)

    it("should return assets") {
      rule.assets must equal (outAssets.assets)
      outAssets.assets.map(_.file.exists).foldLeft(false)(_ || _) must equal (false)
    }

    it("should compile assets") {
      (outDir / "a.js") must not (exist)
      (outDir / "a.js") must (changeDuring {
        rule.compile(log)
      })
      IO.read(outDir / "a.js") must equal {
        """
        |// Generated by CoffeeScript 1.6.2
        |(function() {
        |  alert('a');
        |
        |}).call(this);
        |
        """.trim.stripMargin
      }
      (outDir / "a.js") must not (changeDuring {
        rule.compile(log)
      })
    }

    it("should clean the correct assets") {
      (outDir / "a.js") must exist
      rule.clean(log)

      (inDir / "a.coffee") must exist
      (outDir / "a.js") must not (exist)
    }
  }

  describe("Copy") {
    val inDir      = createTemporaryFiles(
                       "a.txt" -> "a",
                       "b.txt" -> "b",
                       "c.txt" -> "c"
                     )
    val inAssets  = Selectors.Const(List(
                       Asset(Path("/a"), inDir / "a.txt", Nil),
                       Asset(Path("/b"), inDir / "b.txt", Nil),
                       Asset(Path("/c"), inDir / "c.txt", Nil)
                     ))
    val outDir     = IO.createTemporaryDirectory
    val outAssets = Selectors.Const(List(
                       Asset(Path("/a"), outDir / "a.copied.txt", Nil),
                       Asset(Path("/b"), outDir / "b.copied.txt", Nil),
                       Asset(Path("/c"), outDir / "c.copied.txt", Nil)
                     ))
    val rule       = Rules.Copy(
                       outDir,
                       inAssets,
                       Some(
                         (in: Asset) =>
                           in.file.base + ".copied." + in.file.ext
                       ),
                       Some(
                         (in: Asset, contents: List[String]) =>
                           List("[header " + in.path + "]") ++
                           contents ++
                           List("[footer " + in.path + "]")
                       )
                     )

    it("should return assets") {
      rule.assets must equal (outAssets.assets)
      (outDir / "a.copied.txt") must not (exist)
    }

    it("should compile assets") {
      (outDir / "a.copied.txt") must not (exist)
      (outDir / "a.copied.txt") must (changeDuring {
        rule.compile(log)
      })
      IO.read(outDir / "a.copied.txt") must equal ("[header /a]\na\n[footer /a]\n")
      (outDir / "a.copied.txt") must not (changeDuring {
        rule.compile(log)
      })
    }

    it("should clean the correct assets") {
      (outDir / "a.copied.txt") must exist
      rule.clean(log)

      (inDir / "a.txt") must exist
      (outDir / "a.copied.txt") must not (exist)
    }
  }

  describe("LessCss") {
    val inDir      = createTemporaryFiles(
                       "a.less" -> """
                                   |@import "b.less";
                                   |@import "c.less";
                                   |.a { color: red; }
                                   """.trim.stripMargin,
                       "b.less" -> """
                                   |@import "c.less";
                                   |.b { color: green; }
                                   """.trim.stripMargin,
                       "c.less" -> """
                                   |.c { color: blue; }
                                   """.trim.stripMargin
                     )
    val inAssets  = Selectors.Deps(
                      Path("/a"),
                      Resolvers.Dir(inDir)
                    )
    val outDir    = IO.createTemporaryDirectory
    val outAssets = Selectors.Const(List(
                       Asset(Path.Root, outDir / "a.css", Nil)
                     ))
    val rule       = Rules.LessCss(Path("/a"), outDir / "a.css", inAssets)

    it("should return assets") {
      rule.assets must equal (outAssets.assets)
      outAssets.assets.map(_.file.exists).foldLeft(false)(_ || _) must equal (false)
    }

    it("should compile assets") {
      (outDir / "a.css") must not (exist)
      (outDir / "a.css") must (changeDuring {
        rule.compile(log)
      })
      IO.read(outDir / "a.css") must equal {
        """
        |.c {
        |  color: blue;
        |}
        |.b {
        |  color: green;
        |}
        |.c {
        |  color: blue;
        |}
        |.a {
        |  color: red;
        |}
        |
        """.trim.stripMargin
      }
      (outDir / "a.css") must not (changeDuring {
        rule.compile(log)
      })
    }

    it("should clean the correct assets") {
      (outDir / "a.css") must exist
      rule.clean(log)

      (inDir / "a.less") must exist
      (outDir / "a.css") must not (exist)
    }
  }

  describe("NormalizeLessCss") {
    val inDir      = createTemporaryFiles(
                       "a.less" -> """
                                   |@import "b.css";
                                   |@import "c.css";
                                   |.a { color: red; }
                                   """.trim.stripMargin,
                       "b.css"  -> """
                                   |@import "c.css";
                                   |.b { color: green; }
                                   """.trim.stripMargin,
                       "c.css"  -> """
                                   |.c { color: blue; }
                                   """.trim.stripMargin
                     )
    val inAssets   = Selectors.Const(List(
                       Asset(Path("/a"), inDir / "a.less", List(Path("/b"), Path("/c"))),
                       Asset(Path("/b"), inDir / "b.css", List(Path("/c"))),
                       Asset(Path("/c"), inDir / "c.css", Nil)
                     ))
    val outDir     = IO.createTemporaryDirectory
    val outAssets  = Selectors.Const(List(
                       Asset(Path.Root, outDir / "a.less", Nil)
                     ))
    val rule       = Rules.NormalizeLessCss(
                       outDir / "a.less",
                       inAssets
                     )

    it("should return assets") {
      rule.assets must equal (outAssets.assets)
      (outDir / "a.less") must not (exist)
    }

    it("should compile assets") {
      (outDir / "a.less") must not (exist)
      (outDir / "a.less") must (changeDuring {
        rule.compile(log)
      })
      IO.read(outDir / "a.less") must equal {
        """
        |/* Start: /c */
        |.c { color: blue; }
        |/* End: /c */
        |/* Start: /b */
        |.b { color: green; }
        |/* End: /b */
        |/* Start: /a */
        |.a { color: red; }
        |/* End: /a */
        |
        """.trim.stripMargin
      }
      (outDir / "a.less") must not (changeDuring {
        rule.compile(log)
      })
    }

    it("should clean the correct assets") {
      (outDir / "a.less") must exist
      rule.clean(log)

      (inDir / "a.less") must exist
      (outDir / "a.less") must not (exist)
    }
  }

  describe("UglifyJs") {
    val inDir      = createTemporaryFiles(
                       "a.js" -> "a",
                       "b.js" -> "b",
                       "c.js" -> "c"
                     )
    val inAssets  = Selectors.Const(List(
                       Asset(Path("/a"), inDir / "a.js", Nil),
                       Asset(Path("/b"), inDir / "b.js", Nil),
                       Asset(Path("/c"), inDir / "c.js", Nil)
                     ))
    val outDir     = IO.createTemporaryDirectory
    val outAssets = Selectors.Const(List(
                       Asset(Path.Root, outDir / "out.js", Nil)
                     ))
    val rule       = Rules.UglifyJs(outDir / "out.js", inAssets)

    it("should return assets") {
      rule.assets must equal (outAssets.assets)
      (outDir / "out.js") must not (exist)
    }

    it("should compile assets") {
      (outDir / "out.js") must not (exist)
      (outDir / "out.js") must (changeDuring {
        rule.compile(log)
      })
      IO.read(outDir / "out.js") must equal("a;b;c;")
      (outDir / "out.js") must not (changeDuring {
        rule.compile(log)
      })
    }

    it("should clean the correct assets") {
      (outDir / "out.js") must exist
      rule.clean(log)

      (inDir / "a.js") must exist
      (outDir / "out.js") must not (exist)
    }
  }
}